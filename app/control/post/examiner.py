import logging
import re

from app.exceptions.exception import LogicError
from app.process.types import TODO_MARKER

log = logging.getLogger(__name__)


def post_process(language: str, question: str, half_completed_code: str, fully_completed_code: str) -> tuple[str, str, str, str]:
    """Post-processes the practice question and answer blocks to ensure consistency and correctness.

    Args:
        language (str): The language of the coding question
        question (str): The question that is formulated based on the summary.
        half_completed_code (str): The half-completed code with the TODO marker in place of the missing code.
        fully_completed_code (str): The fully-completed code, with the missing parts annotated by the TODO marker filled.
        
    Returns:
        tuple[str, str, str, str]: The language, question, half-completed code, and fully-completed code of the practice generated by the LLM.
    """
    try:
        if not isinstance(question, str):
            raise TypeError(f"Question is not a string: {question}")
        if not isinstance(half_completed_code, str):
            raise TypeError(f"Half-completed code is not a string: {half_completed_code}")
        if not isinstance(fully_completed_code, str):
            raise TypeError(f"Fully-completed code is not a string: {fully_completed_code}")
        if not isinstance(language, str):
            raise TypeError(f"Language is not a string: {language}")

        return (language, question, half_completed_code, fully_completed_code)
    except (ValueError, TypeError) as e:
        log.error(f"Error post-processing practice: {e}")
        raise LogicError(message=str(e))
    except Exception as e:
        log.error(f"Unexpected error while post-processing practice: {e}")
        raise e




def _remove_output_wrapper(text: str) -> str:
    """Removes the output wrapper from the text and returns the remaining text.
    
    Args:
        text (str): The text to be processed.
    
    Returns:
        str: The text without the output wrapper.
    """
    index = text.find("</output>")
    if index == -1:
        raise ValueError(
            f"The text does not contain the expected index '<output>': {text}"
        )
    return text[:index].strip()




def _determine_question_and_answer(block_1: str, block_2: str) -> tuple[str, str]:
    """Determines which is the question and answer block by checking which block contains the {TODO_MARKER}. Returns the question and answer in order.

    Raises:
        ValueError: if neither block contains the {TODO_MARKER}, indicating that the LLM response is of invalid shape

    Returns:
        tuple[str, str]: the question and answer strings respectively.
    """
    if TODO_MARKER not in block_1:
        if TODO_MARKER not in block_2:
            log.error("Neither block contains the placeholder for missing code.")
            raise ValueError(
                f"The placeholder {TODO_MARKER} for missing code is absent."
            )
        # question is block_2, answer is block_1
        return block_2, block_1
    elif TODO_MARKER not in block_2:
        # question is block_1, answer is block_2
        return block_1, block_2
    else:
        log.error("Both blocks contain the placeholder for missing code.")
        raise ValueError(f"Both blocks contain the placeholder {TODO_MARKER}.")


def _extract_code(text: str) -> tuple[str, str, str]:
    """Extracts code enclosed in triple backticks and checks language consistency across question and answer blocks.
    
    Args: 
        text (str): The text to be processed.
    
    Returns:
        tuple[str, str, str]: The language, question block, and answer block respectively.
    """
    pattern = r"```(\w+)\s+(.*?)```"
    matches = re.findall(pattern, text, re.DOTALL)

    if len(matches) != 2:
        raise ValueError("The text should contain exactly two code blocks.")

    language_1, block_1 = matches[0]
    language_2, block_2 = matches[1]

    if language_1 != language_2:
        raise ValueError(
            f"Language mismatch: first block is {language_1}, second block is {language_2}"
        )

    return language_1, block_1, block_2
