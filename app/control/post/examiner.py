import logging
import re

from app.exceptions.exception import LogicError
from app.process.types import TODO_MARKER

log = logging.getLogger(__name__)


def post_process(language: str, question: str, half_completed_code: str, fully_completed_code: str) -> tuple[str, str, str, str]:
    """Post-processes the practice question and answer blocks to ensure consistency and correctness.

    Args:
        language (str): The language of the coding question
        question (str): The question that is formulated based on the summary.
        half_completed_code (str): The half-completed code with the TODO marker in place of the missing code.
        fully_completed_code (str): The fully-completed code, with the missing parts annotated by the TODO marker filled.
        
    Returns:
        tuple[str, str, str, str]: The language, question, half-completed code, and fully-completed code of the practice generated by the LLM.
    """
    try:
        if not isinstance(question, str):
            raise TypeError(f"Question is not a string: {question}")
        if not isinstance(half_completed_code, str):
            raise TypeError(f"Half-completed code is not a string: {half_completed_code}")
        if not isinstance(fully_completed_code, str):
            raise TypeError(f"Fully-completed code is not a string: {fully_completed_code}")
        if not isinstance(language, str):
            raise TypeError(f"Language is not a string: {language}")
        half_completed_code = _verify_todo_marker_presence(half_completed_code=half_completed_code)
        half_completed_code, fully_completed_code = _verify_expected_similarity_and_difference(half_completed_code=half_completed_code, fully_completed_code=fully_completed_code)
        return (language, question, half_completed_code, fully_completed_code)
    except (ValueError, TypeError) as e:
        log.error(f"Error post-processing practice: {e}")
        raise LogicError(message=str(e))
    except Exception as e:
        log.error(f"Unexpected error while post-processing practice: {e}")
        raise e

def _verify_expected_similarity_and_difference(half_completed_code: str, fully_completed_code: str) -> tuple[str, str]:
    """Verifies that the question and answer blocks are similar before the {TODO_MARKER} and different after the {TODO_MARKER}.
    
    This ensures that our output is streamlined for easy verification by the user.

    Args:
        question (str): The question block generated by the LLM.
        answer (str): The answer block generated by the LLM.

    Returns:
        tuple[str, str]: The verified question and answer strings respectively.
    """
    question_lines = half_completed_code.strip().split("\n")
    answer_lines = fully_completed_code.strip().split("\n")
    todo_marker_found = False

    q_index = 0
    a_index = 0

    only_comments: bool = True
    # Loop through each line until we run out of lines in question
    while q_index < len(question_lines):
        if "TODO" in question_lines[q_index]:
            todo_marker_found = True
            q_index += 1
            continue  # Skip TODO marker line and proceed to enforce matching on subsequent lines

        if todo_marker_found:
            # Ensure there are enough lines left in the answer to match the remaining question lines
            if a_index >= len(answer_lines):
                raise ValueError("The answer does not cover all lines in the question after the TODO marker.")

            # Check for matching lines strictly after TODO
            while a_index < len(answer_lines) and question_lines[q_index] != answer_lines[a_index]:
                curr_answer_line: str = answer_lines[a_index].strip()
                if not (curr_answer_line.startswith("#") or curr_answer_line.startswith("//") or curr_answer_line == ""):
                    only_comments = False
                a_index += 1  # Skip non-matching lines in the answer until a match is found

            if a_index < len(answer_lines) and question_lines[q_index] == answer_lines[a_index]:
                if only_comments:
                    raise ValueError("The user input section contains only comments.")
                q_index += 1
                a_index += 1  # Increment both to continue matching
            else:
                raise ValueError("The question and answer blocks differ after the TODO marker.")
        else:
            # Match lines one-to-one before the TODO marker
            if a_index >= len(answer_lines):
                raise ValueError("The answer does not cover all lines in the question before the TODO marker.")
            if question_lines[q_index] != answer_lines[a_index]:
                raise ValueError("The question and answer blocks differ before the TODO marker.")
            q_index += 1
            a_index += 1

    return half_completed_code, fully_completed_code


def _remove_output_wrapper(text: str) -> str:
    """Removes the output wrapper from the text and returns the remaining text.
    
    Args:
        text (str): The text to be processed.
    
    Returns:
        str: The text without the output wrapper.
    """
    index = text.find("</output>")
    if index == -1:
        raise ValueError(
            f"The text does not contain the expected index '<output>': {text}"
        )
    return text[:index].strip()


def _verify_todo_marker_presence(half_completed_code: str) -> str:
    """Verifies that the text contains the {TODO_MARKER}.
    
    Args:
        text (str): The text to be processed.
    
    Returns:
        str: The text with the {TODO_MARKER} if it is present.
    """
    if TODO_MARKER not in half_completed_code:
        raise ValueError(f"The text does not contain the placeholder {TODO_MARKER}.")
    return half_completed_code

def _determine_question_and_answer(block_1: str, block_2: str) -> tuple[str, str]:
    """Determines which is the question and answer block by checking which block contains the {TODO_MARKER}. Returns the question and answer in order.

    Raises:
        ValueError: if neither block contains the {TODO_MARKER}, indicating that the LLM response is of invalid shape

    Returns:
        tuple[str, str]: the question and answer strings respectively.
    """
    if TODO_MARKER not in block_1:
        if TODO_MARKER not in block_2:
            log.error("Neither block contains the placeholder for missing code.")
            raise ValueError(
                f"The placeholder {TODO_MARKER} for missing code is absent."
            )
        # question is block_2, answer is block_1
        return block_2, block_1
    elif TODO_MARKER not in block_2:
        # question is block_1, answer is block_2
        return block_1, block_2
    else:
        log.error("Both blocks contain the placeholder for missing code.")
        raise ValueError(f"Both blocks contain the placeholder {TODO_MARKER}.")


def _extract_code(text: str) -> tuple[str, str, str]:
    """Extracts code enclosed in triple backticks and checks language consistency across question and answer blocks.
    
    Args: 
        text (str): The text to be processed.
    
    Returns:
        tuple[str, str, str]: The language, question block, and answer block respectively.
    """
    pattern = r"```(\w+)\s+(.*?)```"
    matches = re.findall(pattern, text, re.DOTALL)

    if len(matches) != 2:
        raise ValueError("The text should contain exactly two code blocks.")

    language_1, block_1 = matches[0]
    language_2, block_2 = matches[1]

    if language_1 != language_2:
        raise ValueError(
            f"Language mismatch: first block is {language_1}, second block is {language_2}"
        )

    return language_1, block_1, block_2
